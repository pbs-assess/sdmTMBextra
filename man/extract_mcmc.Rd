% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract-mcmc.R
\name{extract_mcmc}
\alias{extract_mcmc}
\title{Extract MCMC samples from an sdmTMB model fit with tmbstan.}
\usage{
extract_mcmc(object)
}
\arguments{
\item{object}{Output from \code{\link[tmbstan:tmbstan]{tmbstan::tmbstan()}} run on the \code{tmb_obj}
element of an \code{\link[sdmTMB:sdmTMB]{sdmTMB::sdmTMB()}} model. E.g.,
\code{tmbstan::tmbstan(your_model$tmb_obj)}.}
}
\value{
Returns a matrix of parameter samples. Rows correspond to the order
of \code{your_model$tmb_obj$env$last.par.best}. Columns correspond to
posterior samples. The output can be passed to \code{\link[sdmTMB:predict.sdmTMB]{sdmTMB::predict.sdmTMB()}} to
make fully Bayesian predictions. See the \code{mcmc_samples} argument in
\code{\link[sdmTMB:predict.sdmTMB]{sdmTMB::predict.sdmTMB()}}.
}
\description{
Extract MCMC samples from an sdmTMB model fit with tmbstan.
}
\examples{
\dontshow{if (sdmTMB::ggplot2_installed()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}

library(sdmTMB)
library(sdmTMBextra)
mesh <- make_mesh(pcod_2011, c("X", "Y"), cutoff = 35) # quite coarse

# Fit with marginal maximum likelihood first:

fit <- sdmTMB(
  density ~ 0 + as.factor(year),
  data = pcod_2011, mesh = mesh,
  family = tweedie(link = "log"),
  priors = sdmTMBpriors(
    matern_s = pc_matern(range_gt = 10, sigma_lt = 5),
    matern_st = pc_matern(range_gt = 10, sigma_lt = 5),
    b = normal(rep(0, 4), scale = rep(10, 4)) # 4 main effects
  ),
  time = "year"
)
fit

# Create a 'map' vector for TMB to 'fix' kappa at the MLE value
# to improve speed of convergence.
# Factor NA values cause TMB to fix or map the parameter
# at the starting value.

pars <- sdmTMB::get_pars(fit)
kappa_map <- factor(rep(NA, length(pars$ln_kappa)))

# Rebuild model updating some elements:
fit_mle <- update(
  fit,
  control = sdmTMBcontrol(
    start = list(
      ln_kappa = pars$ln_kappa
    ),
    map = list(
      ln_kappa = kappa_map
    )
  ),
  do_fit = FALSE # no need to actually fit
)

# Will take a few minutes:
library(tmbstan)
m_stan <- tmbstan(fit_mle$tmb_obj, iter = 100, chains = 1)
print(
  m_stan,
  pars = c("b_j", "thetaf", "ln_phi", "omega_s[1]", "epsilon_st[1]")
)


nd <- replicate_df(qcs_grid, "year", unique(pcod_2011$year))

post <- sdmTMBextra::extract_mcmc(m_stan)
p <- predict(fit_mle, newdata = nd, mcmc_samples = post)

p_last <- p[nd$year == max(nd$year), ] # just plot last year
pred <- nd[nd$year == max(nd$year), ]
pred$est <- apply(exp(p_last), 1, median)
pred$lwr <- apply(exp(p_last), 1, quantile, probs = 0.1)
pred$upr <- apply(exp(p_last), 1, quantile, probs = 0.9)
pred$cv <- apply(exp(p_last), 1, function(x) sd(x) / mean(x))

library(ggplot2)
ggplot(pred, aes(X, Y, fill = est)) + geom_raster() +
  scale_fill_viridis_c(trans = "log")
ggplot(pred, aes(X, Y, fill = cv)) + geom_raster() +
  scale_fill_viridis_c(trans = "log")

index_quantiles <- get_index_sims(p)
ggplot(index_quantiles, aes(year, est, ymin = lwr, ymax = upr)) +
  geom_line() + geom_ribbon(alpha = 0.5)

index_samples <- get_index_sims(p, return_sims = TRUE)
ggplot(index_samples, aes(as.factor(year), .value)) +
  geom_violin()
\dontshow{\}) # examplesIf}
}
